int 打印课表(void);//未完工
int 查看日志(void);//未完工

int 数据校验(int 转换类型) {
	临时数据 循环[3], 课程ID;
	printf("数据校验・・・\n");
	switch (转换类型) {
	case 0:
		for (循环[0].整数型 = 0; 循环[0].整数型 < 用户数量; 循环[0].整数型++) {//将学生选课信息录入到课程数据中
			if (用_户[循环[0].整数型].权限类型 != 3)continue;//跳过学校和教师
			else if (用_户[循环[0].整数型].课程数量 > 选课上限) continue;
			for (循环[1].整数型 = 0; 循环[1].整数型 < 用_户[循环[0].整数型].课程数量; 循环[1].整数型++) {
				课程ID.整数型 = 课程_ID查询(用_户[循环[0].整数型].课程代码[循环[1].整数型]);
				if (课程ID.整数型 < 0) { 用_户[循环[0].整数型].课程代码[循环[1].整数型] *= -1; continue; }
				用_户[循环[0].整数型].课程代码[循环[1].整数型] = 课程ID.整数型;//转换为内部代码
				for (循环[2].整数型 = 0; 循环[2].整数型 < 课_程[课程ID.整数型].用户数量; 循环[2].整数型++)
					if (课_程[课程ID.整数型].用户ID[循环[2].整数型] == 循环[0].整数型) break;
				if (循环[2].整数型 == 课_程[课程ID.整数型].用户数量) {
					课_程[课程ID.整数型].用户ID = (int*)realloc(课_程[课程ID.整数型].用户ID, sizeof(int) * ++课_程[课程ID.整数型].用户数量);
					课_程[课程ID.整数型].用户ID[课_程[课程ID.整数型].用户数量 - 1] = 循环[0].整数型;
				}
			}
		}
		break;
	case 1:
		for (循环[0].整数型 = 0; 循环[0].整数型 < 用户数量; 循环[0].整数型++) {
			if (用_户[循环[0].整数型].权限类型 != 3)continue;
			else if (用_户[循环[0].整数型].课程数量 > 选课上限) continue;
			for (循环[1].整数型 = 0; 循环[1].整数型 < 用_户[循环[0].整数型].课程数量; 循环[1].整数型++)
				if (用_户[循环[0].整数型].课程代码[循环[1].整数型] >= 0)用_户[循环[0].整数型].课程代码[循环[1].整数型] = 课_程[用_户[循环[0].整数型].课程代码[循环[1].整数型]].课程代码;
				else 用_户[循环[0].整数型].课程代码[循环[1].整数型] *= -1;
		}
	}
	printf("数据校验√√√\n");
	return 0;
}
int 带检测输入(void* 待存入变量, int 输入类型) {
	临时数据 判断;
	switch (输入类型) {
	case 1:判断.整数型 = scanf("%d", (int*)待存入变量); break;
	case 2:判断.整数型 = scanf("%lf", (double*)待存入变量); break;
	case 3:判断.整数型 = scanf("%s", (char*)待存入变量); break;
	default:判断.整数型 = 0; break;
	}
	rewind(stdin);//fflush(stdin); 重定义/清空输入缓存区
	return 判断.整数型 == 1 ? 判断.整数型 : (printf("输入非法,请重新输入!\n"), 带检测输入(待存入变量, 输入类型) + 判断.整数型);
}//返回重新输入的次数
int 字符串加解密(char* 加密字符串) {
	临时数据 次数;
	次数.整数型 = 0;
	while (*加密字符串 != '\0') {
		if (*加密字符串 > '0' && *加密字符串 <= '9') *加密字符串 -= 16;
		else if (*加密字符串 >= '!' && *加密字符串 <= ')')*加密字符串 += 16;
		else if (*加密字符串 >= 'A' && *加密字符串 < 'Z')*加密字符串 = 'A' + 'Y' - *加密字符串;
		else if (*加密字符串 > 'a' && *加密字符串 <= 'z')*加密字符串 = 'a' + 'z' - *加密字符串;
		次数.整数型++, 加密字符串++;
	}
	return 次数.整数型;
}//返回字符串加密步骤数
int 筛选判断(int 课程ID) {
	临时数据 循环[2], 判断内容;
	if (课_程[课程ID].学生上限 - 课_程[课程ID].用户数量 < 筛选条件[5][0]) return 1;
	for (循环[0].整数型 = 0; 循环[0].整数型 < 5; 循环[0].整数型++) {
		switch (循环[0].整数型) {
		case 0:判断内容.整数型 = 课_程[课程ID].选课性质; break;
		case 1:判断内容.整数型 = 课_程[课程ID].选课类型; break;
		case 2:判断内容.整数型 = 课_程[课程ID].学期; break;
		case 3:判断内容.整数型 = 课_程[课程ID].上课时间; break;
		case 4:判断内容.整数型 = 课_程[课程ID].上课地点; break;
		}
		for (循环[1].整数型 = 0; 循环[1].整数型 < 10; 循环[1].整数型++)
			if (筛选条件[循环[0].整数型][循环[1].整数型] && 判断内容.整数型 == 循环[1].整数型)
				return 1;
	}
	return 0;
}//判断显示返回0，隐藏返回1
int 用户_ID查询(char* 账号) {
	临时数据 个数, 循环, 目标ID;
	for (目标ID.整数型 = -1, 个数.整数型 = 循环.整数型 = 0; 循环.整数型 < 用户数量; 循环.整数型++)
		if (!strcmp(账号, 用_户[循环.整数型].账号)) 个数.整数型++, 目标ID.整数型 = 循环.整数型;
	if (个数.整数型 == 1) return 目标ID.整数型;
	else return -个数.整数型 - 1;
}//找到一个则返回正确ID，未找到则返回-1，找到多个返回-（1+个数）
int 课程_ID查询(int 课程代码) {
	临时数据 个数, 循环, 目标ID;
	for (目标ID.整数型 = -1, 个数.整数型 = 循环.整数型 = 0; 循环.整数型 < 课程数量; 循环.整数型++)
		if (课程代码 == 课_程[循环.整数型].课程代码) 个数.整数型++, 目标ID.整数型 = 循环.整数型;
	if (个数.整数型 == 1) return 目标ID.整数型;
	else return -个数.整数型 - 1;
}
int 课程操作(int 课程ID) {
	课程 临时课程;
	临时数据 操作, 循环;
	system("cls");
	if (课程ID == -1) {
		printf("新建课程\n请输入新建课程代码：");
		带检测输入(&临时课程.课程代码, 1);
		if (课程_ID查询(临时课程.课程代码) != -1) { printf("该课程已存在!\n"); system("pause"); system("cls"); return -1; }
		printf("请输入新建教师代码：");
		带检测输入(临时课程.教师代码, 3);
		if ((操作.整数型 = 用户_ID查询(临时课程.教师代码)) < 0) { printf("该教师信息有误!\n"); system("pause"); system("cls"); return -1; }
		课_程 = (课程*)realloc(课_程, sizeof(课程) * ++课程数量);
		课_程[课程数量 - 1].课程代码 = 临时课程.课程代码; strcpy(课_程[课程数量 - 1].教师代码, 临时课程.教师代码);
		printf("请输入新建课程名字：");
		带检测输入(课_程[课程数量 - 1].课程名字, 3);
		printf("请依序输入(空格隔开)：[学分][选课性质][选课类型][学期][上课时间][上课地点][学生上限]\n->");
		while (scanf("%d%d%d%d%d%d%d", &课_程[课程数量 - 1].学分, &课_程[课程数量 - 1].选课性质, &课_程[课程数量 - 1].选课类型, &课_程[课程数量 - 1].学期, &课_程[课程数量 - 1].上课时间, &课_程[课程数量 - 1].上课地点, &课_程[课程数量 - 1].学生上限) != 7) printf("输入非法,请重新输入:");
		用_户[操作.整数型].课程代码 = (int*)realloc(用_户[操作.整数型].课程代码, sizeof(int) * ++用_户[操作.整数型].课程数量);
		用_户[操作.整数型].课程代码[用_户[操作.整数型].课程数量 - 1] = 课程数量 - 1;
		printf("新建课程√√√");
		导出课程(0);
		return 1;
	}
	else {
		printf("课程信息\n[1]课程代码：%d\t[2]课程名字：%s\t[3]学生上限：%d\n[4]学分：%d\t[5]教师代码：%s\t[6]选课性质：%d\n[7]学期：%d\t[8]上课地点：%d\t\t[9]上课时间：%d\n[10]选课类型：%d\t\t\t\t[0]删除课程\n", 课_程[课程ID].课程代码, 课_程[课程ID].课程名字, 课_程[课程ID].学生上限, 课_程[课程ID].学分, 课_程[课程ID].教师代码, 课_程[课程ID].选课性质, 课_程[课程ID].学期, 课_程[课程ID].上课地点, 课_程[课程ID].上课时间, 课_程[课程ID].选课类型);
		printf("输入序号进行修改,其他数字返回:");
		带检测输入(&操作.整数型, 1);
		switch (操作.整数型) {
		case 0:
			for (循环.整数型 = 0; 循环.整数型 < 课_程[课程ID].用户数量; 循环.整数型++)
				退课(课_程[课程ID].用户ID[循环.整数型], 课程ID);
			课_程[课程ID].课程代码 = -1;
			导出课程(0); 导出用户(0);
			break;
		case 1:
			printf("请输入新课程代码：");
			带检测输入(&临时课程.课程代码, 1);
			if (课程_ID查询(临时课程.课程代码) != -1) { printf("该课程已存在!\n"); system("pause"); system("cls"); return -1; }
			课_程[课程ID].课程代码 = 临时课程.课程代码;
			导出课程(0);
			break;
		case 2:
			printf("请输入新课程名字：");
			带检测输入(课_程[课程ID].课程名字, 3);
			导出课程(0);
			break;
		case 3:
			printf("请输入新学生上限：");
			带检测输入(&课_程[课程ID].学生上限, 1);
			导出课程(0);
			break;
		case 4:
			printf("请输入新学分：");
			带检测输入(&课_程[课程ID].学分, 1);
			导出课程(0);
			break;
		case 5:
			printf("请输入新教师代码：");
			带检测输入(临时课程.教师代码, 3);
			if (用户_ID查询(临时课程.教师代码) < 0) { printf("该教师不存在或存在问题!\n"); system("pause"); system("cls"); return -1; }
			strcpy(课_程[课程ID].教师代码, 临时课程.教师代码);
			导出课程(0);
			break;
		case 6:
			printf("请输入新选课性质：");
			带检测输入(&课_程[课程ID].选课性质, 1);
			导出课程(0);
			break;
		case 7:
			printf("请输入新学期：");
			带检测输入(&课_程[课程ID].学期, 1);
			导出课程(0);
			break;
		case 8:
			printf("请输入新上课地点：");
			带检测输入(&课_程[课程ID].上课地点, 1);
			导出课程(0);
			break;
		case 9:
			printf("请输入新上课时间：");
			带检测输入(&课_程[课程ID].上课时间, 1);
			导出课程(0);
			break;
		case 10:
			printf("请输入新选课类型：");
			带检测输入(&课_程[课程ID].选课类型, 1);
			导出课程(0);
			break;
		default:system("cls"); return 1;
		}
	}
	system("cls");
	return 0;
}
int 用户操作(int 用户ID) {
	用户 临时用户;
	临时数据 操作, 循环;
	system("cls");
	if (用户ID == -1) {
		printf("新建用户\n请输入新建用户权限类型：");
		带检测输入(&临时用户.权限类型, 1);
		if (临时用户.权限类型 > 3 || 临时用户.权限类型 < 0) { printf("错误的权限类型!\n"); system("pause"); system("cls"); return -1; }
		printf("请输入新建用户账号：");
		带检测输入(临时用户.账号, 3);
		if (用户_ID查询(临时用户.账号) != -1) { printf("该账号已存在!\n"); system("pause"); system("cls"); return -1; }
		printf("请输入新建用户密码：");
		带检测输入(临时用户.密码, 3);
		用_户 = (用户*)realloc(用_户, sizeof(用户) * ++用户数量);
		用_户[用户数量 - 1].权限类型 = 临时用户.权限类型; strcpy(用_户[用户数量 - 1].账号, 临时用户.账号); strcpy(用_户[用户数量 - 1].密码, 临时用户.密码);
		if (用_户[用户数量 - 1].权限类型 != 1) {
			printf("请输入新建用户姓名：");
			带检测输入(用_户[用户数量 - 1].姓名, 3);
		}
		if (用_户[用户数量 - 1].权限类型 == 3) {
			用_户[用户数量 - 1].课程数量 = 0;
			用_户[用户数量 - 1].课程代码 = NULL;
			printf("请输入新建用户课程代码(输入课程代码外的数字时中止)：");
			while (带检测输入(&操作.整数型, 1), (操作.整数型 = 课程_ID查询(操作.整数型)) >= 0) {
				用_户[用户数量 - 1].课程代码 = (int*)realloc(用_户[用户数量 - 1].课程代码, sizeof(int) * ++用_户[用户数量 - 1].课程数量);
				带检测输入(&用_户[用户数量 - 1].课程代码[用_户[用户数量 - 1].课程数量 - 1], 1);
			}
		}
		printf("新建用户√√√");
		导出用户(0);
	}
	else {
		printf("用户信息\n[1]权限类型：%d\t[2]账号：%s\n[3]修改密码\t[0]删除账号\n", 用_户[用户ID].权限类型, 用_户[用户ID].账号, 用_户[用户ID].密码);
		if (用_户[用户ID].权限类型 != 1) printf("[4]课程信息\n");
		printf("输入序号进行修改,其他数字返回:");
		带检测输入(&操作.整数型, 1);
		switch (操作.整数型) {
		case 0:
			if (用_户[用户ID].权限类型 == 3)
				for (循环.整数型 = 0; 循环.整数型 < 用_户[用户ID].课程数量; 循环.整数型++)
					退课(用户ID, 用_户[用户ID].课程代码[0]);
			用_户[用户ID].权限类型 = -1;
			导出用户(0);
			break;
		case 1:
			printf("请输入新权限类型：");
			带检测输入(&用_户[用户ID].权限类型, 1);
			导出用户(0);
			break;
		case 2:
			printf("请输入新账号：");
			带检测输入(&临时用户.账号, 3);
			if (用户_ID查询(临时用户.账号) != -1) { printf("该账号已存在!\n"); system("pause"); system("cls"); return -1; }
			strcpy(用_户[用户ID].账号, 临时用户.账号);
			导出用户(0);
			break;
		case 3:while (修改密码(用户ID)); break;
		case 4:
			if (用_户[用户ID].权限类型 == 1) { system("cls"); return 1; }
			else if (用_户[用户ID].权限类型 == 2) while (!我的学生(用户ID));
			else while (!我的课程(用户ID)); break;
			break;
		default:system("cls"); return 1;
		}
	}
	system("cls");
	return 0;
}
int 添加课程(int 用户ID, int 课程ID) {
	临时数据 循环;
	for (循环.整数型 = 0; 循环.整数型 < 用_户[用户ID].课程数量; 循环.整数型++)
		if (用_户[用户ID].课程代码[循环.整数型] == 课程ID) {
			printf("该课程已在选课中！\n");
			return -1;
		}
	用_户[用户ID].课程代码 = (int*)realloc(用_户[用户ID].课程代码, sizeof(int) * ++用_户[用户ID].课程数量);
	用_户[用户ID].课程代码[用_户[用户ID].课程数量 - 1] = 课程ID;
	导出课程(0);
	return 0;
}
int 退课(int 用户ID, int 课程ID) {
	临时数据 循环;
	for (循环.整数型 = 0; 循环.整数型 < 用_户[用户ID].课程数量; 循环.整数型++)
		if (用_户[用户ID].课程代码[循环.整数型] == 课程ID) break;
	用_户[用户ID].课程代码[循环.整数型] = 用_户[用户ID].课程代码[--用_户[用户ID].课程数量];
	for (循环.整数型 = 0; 循环.整数型 < 课_程[课程ID].用户数量; 循环.整数型++)
		if (课_程[课程ID].用户ID[循环.整数型] == 用户ID) break;
	课_程[课程ID].用户ID[循环.整数型] = 课_程[课程ID].用户ID[--课_程[课程ID].用户数量];
	导出课程(0); 导出用户(0);
	return 0;
}
int 搜索用户(void) {
	临时数据 账号, 循环, 计数, 操作;
	switch (用_户[登录用户ID].权限类型) {
	case 1:
		printf("请输入用户账号:");
		带检测输入(账号.文本型, 3);
		账号.整数型 = 用户_ID查询(账号.文本型);
		if (账号.整数型 == -1) { printf("该账号不存在!\n"); system("pause"); system("cls"); return 1; }
		else if (账号.整数型 < 0) { printf("该账号信息错误!\n错误代码：%d", 账号.整数型); system("pause"); system("cls"); return 1; }
		while (!用户操作(账号.整数型));
		break;
	case 2:
		printf("请输入学生学号:");
		带检测输入(账号.文本型, 3);
		账号.整数型 = 用户_ID查询(账号.文本型);
		if (账号.整数型 == -1) { printf("该学生不存在!\n"); system("pause"); system("cls"); return 1; }
		else if (账号.整数型 < 0) { printf("该学生信息错误!请联系管理员纠正", 账号.整数型); system("pause"); system("cls"); return 1; }
		do {
			printf("序号\t课程代码\t课程名字\t选课人数\n");
			for (计数.整数型 = 循环.整数型 = 0; 循环.整数型 < 用_户[账号.整数型].课程数量; 循环.整数型++)
				if (用_户[账号.整数型].课程代码[循环.整数型] >= 0 && 用_户[账号.整数型].课程代码[循环.整数型] < 课程数量 && !strcmp(课_程[用_户[账号.整数型].课程代码[循环.整数型]].教师代码, 用_户[登录用户ID].账号))
				{
					计数.整数型++;
					printf("[%d]\t%d\t\t%s\t\t%d/%d\n", 循环.整数型 + 1, 课_程[用_户[账号.整数型].课程代码[循环.整数型]].课程代码, 课_程[用_户[账号.整数型].课程代码[循环.整数型]].课程名字, 课_程[用_户[账号.整数型].课程代码[循环.整数型]].用户数量, 课_程[用_户[账号.整数型].课程代码[循环.整数型]].学生上限);
				}
			printf("学生学号:%s\t学生姓名:%s\t选课数:%d\n", 用_户[账号.整数型].账号, 用_户[账号.整数型].姓名, 计数.整数型);
			printf("请输入序号退课或其他任意键返回：");
			带检测输入(&操作.整数型, 1);
			if (操作.整数型 > 0 && 操作.整数型 < 循环.整数型 + 2) 退课(账号.整数型, 用_户[账号.整数型].课程代码[操作.整数型 - 1]);
			system("cls");
		} while (操作.整数型 > 0 && 操作.整数型 < 循环.整数型 + 2);
		break;
	}
	return 0;
}
int 搜索课程(void) {
	临时数据 课程, 循环, 操作;
	printf("请输入课程代码:");
	带检测输入(&课程.整数型, 1);
	课程.整数型 = 课程_ID查询(课程.整数型);
	switch (用_户[登录用户ID].权限类型) {
	case 1:
		if (课程.整数型 == -1) { printf("该课程不存在!\n"); system("pause"); system("cls"); return 1; }
		else if (课程.整数型 < 0) { printf("该课程信息错误!\n错误代码：%d", 课程.整数型); system("pause"); system("cls"); return 1; }
		while (!课程操作(课程.整数型));
		break;
	case 2:case 3:
		printf("课程代码：%d\t课程名字：%s\t学生上限：%d\n学分：%d\t教师代码：%s\t选课性质：%d\n学期：%d\t上课地点：%d\t\t上课时间：%d\n选课类型：%d\n", 课_程[课程.整数型].课程代码, 课_程[课程.整数型].课程名字, 课_程[课程.整数型].学生上限, 课_程[课程.整数型].学分, 课_程[课程.整数型].教师代码, 课_程[课程.整数型].选课性质, 课_程[课程.整数型].学期, 课_程[课程.整数型].上课地点, 课_程[课程.整数型].上课时间, 课_程[课程.整数型].选课类型);
		if (用_户[登录用户ID].权限类型 == 3) {
			printf("是否选课(1-是，其他键-返回):");
			带检测输入(&操作.整数型, 1);
			if (操作.整数型 == 1) 添加课程(登录用户ID, 1);
		}
		system("pause");
		break;
	}
	return 0;
}
int 浏览用户(void) {
	临时数据 循环[2], 操作;
	printf("浏览用户(共%d条数据)\n序号\t权限类型\t账号\t姓名\t\t课程代码\n", 用户数量);
	for (循环[0].整数型 = 0; 循环[0].整数型 < 用户数量; 循环[0].整数型++, printf("\n")) {
		printf("[%d]\t%d\t\t%s\t", 循环[0].整数型 + 1, 用_户[循环[0].整数型].权限类型, 用_户[循环[0].整数型].账号);
		if (用_户[循环[0].整数型].权限类型 == 1) continue;
		printf("%-10s\t", 用_户[循环[0].整数型].姓名);
		for (循环[1].整数型 = 0; 循环[1].整数型 < 用_户[循环[0].整数型].课程数量; 循环[1].整数型++)
			if (用_户[循环[0].整数型].课程代码[循环[1].整数型] >= 0 && 用_户[循环[0].整数型].课程代码[循环[1].整数型] < 课程数量)
				printf("%d ", 课_程[用_户[循环[0].整数型].课程代码[循环[1].整数型]].课程代码);
	}
	printf("输入序号查看详细信息,输入0新建用户,其他任意键返回：");
	带检测输入(&操作.整数型, 1);
	if (操作.整数型 == 0) while (!用户操作(-1));//新建
	else if (操作.整数型 > 用户数量 || 操作.整数型 < 0) { system("cls"); return 1; }
	else while (!用户操作(操作.整数型 - 1));
	system("cls");
	return 0;
}
int 浏览课程(void) {
	临时数据 循环, 操作;
	printf("浏览课程(共%d条数据)\n%-6s\t\t%-10s\t%-15s\t%-5s\t%-15s\t%-10s\t%-10s\t%-10s\t%-10s\t%-10s\t%s\n", 课程数量, "序号", "课程代码", "教师姓名", "学分", "选课性质[-1]", "选课类型[-2]", "学期[-3]", "上课时间[-4]", "课程名字", "上课地点[-5]", "选课人数[-6]");
	for (循环.整数型 = 0; 循环.整数型 < 课程数量; 循环.整数型++)
		if (!筛选判断(循环.整数型))
			printf("[%06d]\t%-10d\t%-15s\t%-5d\t%-15s\t%-10s\t%-10s\t%-10s\t%-10s\t%-10s\t%d/%d\n", 循环.整数型 + 1, 课_程[循环.整数型].课程代码, 用_户[用户_ID查询(课_程[循环.整数型].教师代码)].姓名, 课_程[循环.整数型].学分, 选课性质[课_程[循环.整数型].选课性质], 选课类型[课_程[循环.整数型].选课类型], 学期[课_程[循环.整数型].学期], 上课时间[课_程[循环.整数型].上课时间], 课_程[循环.整数型].课程名字, 上课地点[课_程[循环.整数型].上课地点], 课_程[循环.整数型].用户数量, 课_程[循环.整数型].学生上限);
	if (用_户[登录用户ID].权限类型 == 1)printf("输入-6到-1进行筛选，输入序号查看详细信息，输入0新建课程，其他任意键返回：");
	else if (用_户[登录用户ID].权限类型 == 2)printf("输入-6到-1进行筛选，其他任意键返回：");
	else if (用_户[登录用户ID].权限类型 == 3)printf("输入-6到-1进行筛选，输入序号选课，其他任意键返回");
	带检测输入(&操作.整数型, 1);
	if (用_户[登录用户ID].权限类型 == 1 && 操作.整数型 == 0) while (!课程操作(-1));
	else if (操作.整数型 >= -6 && 操作.整数型 <= -1) {//筛选
		printf("筛选（0-显示，1-隐藏）\n");
		switch (操作.整数型) {
		case -1:
			printf("选课性质:");
			for (循环.整数型 = 0; 循环.整数型 < 选课性质_数量; 循环.整数型++)
				printf("[%d]%s(%d) ", 循环.整数型 + 1, 选课性质[循环.整数型], 筛选条件[0][循环.整数型]);
			printf("\n输入序列改变显示状态：");
			带检测输入(&操作.整数型, 1);
			筛选条件[0][操作.整数型 - 1] = 1 - 筛选条件[0][操作.整数型 - 1];
			break;
		case -2:
			printf("选课类型:");
			for (循环.整数型 = 0; 循环.整数型 < 选课类型_数量; 循环.整数型++)
				printf("[%d]%s(%d) ", 循环.整数型 + 1, 选课类型[循环.整数型], 筛选条件[1][循环.整数型]);
			printf("\n输入序列改变显示状态：");
			带检测输入(&操作.整数型, 1);
			筛选条件[1][操作.整数型 - 1] = 1 - 筛选条件[1][操作.整数型 - 1];
			break;
		case -3:
			printf("学期:");
			for (循环.整数型 = 0; 循环.整数型 < 学期_数量; 循环.整数型++)
				printf("[%d]%s(%d) ", 循环.整数型 + 1, 学期[循环.整数型], 筛选条件[2][循环.整数型]);
			printf("\n输入序列改变显示状态：");
			带检测输入(&操作.整数型, 1);
			筛选条件[2][操作.整数型 - 1] = 1 - 筛选条件[2][操作.整数型 - 1];
			break;
		case -4:
			printf("上课时间:");
			for (循环.整数型 = 0; 循环.整数型 < 上课时间_数量; 循环.整数型++)
				printf("[%d]%s(%d) ", 循环.整数型 + 1, 上课时间[循环.整数型], 筛选条件[3][循环.整数型]);
			printf("\n输入序列改变显示状态：");
			带检测输入(&操作.整数型, 1);
			筛选条件[3][操作.整数型 - 1] = 1 - 筛选条件[3][操作.整数型 - 1];
			break;
		case -5:
			printf("上课地点:");
			for (循环.整数型 = 0; 循环.整数型 < 上课地点_数量; 循环.整数型++)
				printf("[%d]%s(%d) ", 循环.整数型 + 1, 上课地点[循环.整数型], 筛选条件[4][循环.整数型]);
			printf("\n输入序列改变显示状态：");
			带检测输入(&操作.整数型, 1);
			筛选条件[4][操作.整数型 - 1] = 1 - 筛选条件[4][操作.整数型 - 1];
			break;
		case -6:
			printf("选课数:剩余空间≥%d人,调整人数为：", 筛选条件[5][0]);
			带检测输入(&筛选条件[5][0], 1);
			break;
		}
	}
	else if (操作.整数型 > 课程数量 || 用_户[登录用户ID].权限类型 == 2) { system("cls"); return 1; }
	else
		switch (用_户[登录用户ID].权限类型) {
		case 1:while (!课程操作(操作.整数型 - 1)); break;
		case 3:添加课程(登录用户ID, 操作.整数型 - 1); break;
		}
	system("cls");
	return 0;
}
int 我的课程(int 用户ID) {
	临时数据 循环, 操作;
	system("cls");
	printf("%s的课程信息\n%-6s\t\t%-10s\t%-15s\t%-5s\t%-15s\t%-10s\t%-10s\t%-10s\t%-10s\t%-10s\t%s\n", 用_户[用户ID].账号, "序号", "课程代码", "教师名字", "学分", "选课性质", "选课类型", "学期", "上课时间", "课程名字", "上课地点", "选课数");
	for (循环.整数型 = 0; 循环.整数型 < 用_户[用户ID].课程数量; 循环.整数型++)
		if (用_户[用户ID].课程代码[循环.整数型] >= 0 && 用_户[用户ID].课程代码[循环.整数型] < 课程数量)
			printf("[%06d]\t%-10d\t%-15s\t%-5d\t%-15s\t%-10s\t%-10s\t%-10s\t%-10s\t%-10s\t%d/%d\n", 循环.整数型 + 1, 课_程[用_户[用户ID].课程代码[循环.整数型]].课程代码, 用_户[用户_ID查询(课_程[用_户[用户ID].课程代码[循环.整数型]].教师代码)].姓名, 课_程[用_户[用户ID].课程代码[循环.整数型]].学分, 选课性质[课_程[用_户[用户ID].课程代码[循环.整数型]].选课性质], 选课类型[课_程[用_户[用户ID].课程代码[循环.整数型]].选课类型], 学期[课_程[用_户[用户ID].课程代码[循环.整数型]].学期], 上课时间[课_程[用_户[用户ID].课程代码[循环.整数型]].上课时间], 课_程[用_户[用户ID].课程代码[循环.整数型]].课程名字, 上课地点[课_程[用_户[用户ID].课程代码[循环.整数型]].上课地点], 课_程[用_户[用户ID].课程代码[循环.整数型]].用户数量, 课_程[用_户[用户ID].课程代码[循环.整数型]].学生上限);
	if (用_户[用户ID].权限类型 == 3) {
		printf("输入序号退课，其他任意输入返回：");
		带检测输入(&操作.整数型, 1);
		if (操作.整数型<1 || 操作.整数型>用_户[用户ID].课程数量) { system("cls"); return 1; }
		else 退课(用户ID, 用_户[用户ID].课程代码[操作.整数型]);
	}
	else { system("pause"); system("cls"); return 1; }
	system("cls");
	return 0;
}
int 我的学生(int 教师ID) {
	临时数据 循环[2], 操作[3], 用户ID;
	system("cls");
	printf("%s的学生信息\n课程代码\t课程名字\t序列\t学号\t学生姓名\n", 用_户[教师ID].账号);
	for (循环[0].整数型 = 0; 循环[0].整数型 < 用_户[教师ID].课程数量; 循环[0].整数型++) {
		printf("%05d\t\t%s\t\t[%d]\t共%d/%d位学生\n", 课_程[用_户[教师ID].课程代码[循环[0].整数型]].课程代码, 课_程[用_户[教师ID].课程代码[循环[0].整数型]].课程名字, 循环[0].整数型 + 1, 课_程[用_户[教师ID].课程代码[循环[0].整数型]].用户数量, 课_程[用_户[教师ID].课程代码[循环[0].整数型]].学生上限);
		for (循环[1].整数型 = 0; 循环[1].整数型 < 课_程[用_户[教师ID].课程代码[循环[0].整数型]].用户数量; 循环[1].整数型++)
			if (用_户[课_程[用_户[教师ID].课程代码[循环[0].整数型]].用户ID[循环[1].整数型]].权限类型 != -1)
				printf("\t\t\t\t[%d]\t%s\t%s\n", 循环[1].整数型 + 1, 用_户[课_程[用_户[教师ID].课程代码[循环[0].整数型]].用户ID[循环[1].整数型]].账号, 用_户[课_程[用_户[教师ID].课程代码[循环[0].整数型]].用户ID[循环[1].整数型]].姓名);
	}
	printf("[课程序号_学生序号]退课\n[课程序号_0]添加学生\n[其他输入]返回\n请输入数字继续操作:");
	if (!scanf("%d_%d", &操作[0].整数型, &操作[1].整数型) || 操作[0].整数型<0 || 操作[1].整数型<0 || 操作[0].整数型>用_户[教师ID].课程数量 || 操作[1].整数型>课_程[用_户[教师ID].课程代码[循环[0].整数型]].用户数量) {
		printf("其他输入或下标越界！\n");
		system("pause"); system("cls");
		return -1;
	}
	if (!操作[0].整数型) {
		printf("请输入待添加学生的学号:");
		带检测输入(操作[2].文本型, 3);
		用户ID.整数型 = 用户_ID查询(操作[2].文本型);
		if (用户ID.整数型 < 0) { printf("该学生信息存在问题，请联系管理员纠正!\n"); system("pause"); system("cls"); return -1; }
		else 添加课程(用户ID.整数型, 课_程[用_户[教师ID].课程代码[操作[0].整数型]].课程代码);
	}
	else 退课(用户ID.整数型, 课_程[用_户[教师ID].课程代码[操作[0].整数型]].课程代码);
	return 0;
}//返回查询到的个数
int 修改密码(int 用户ID) {
	临时数据 密码_第一遍, 密码_第二遍;
	printf("请输入修改的密码:");
	带检测输入(密码_第一遍.文本型, 3);
	printf("请再次确认的密码:");
	带检测输入(密码_第二遍.文本型, 3);
	if (strcmp(密码_第一遍.文本型, 密码_第二遍.文本型)) {
		printf("两次密码不相同，请重新输入！\n");
		system("pause"); system("cls");
		return -1;
	}
	else {
		strcpy(用_户[用户ID].密码, 密码_第一遍.文本型);
		printf("密码修改成功！\n");
		system("pause"); system("cls");
		return 0;
	}
}
int 导入课程(int 操作类型) {
	临时数据 位置信息, 载入, 文件位置_下一行, 文件位置_当前行, 账号;
	if (操作类型) {//定位文件位置
		printf("请输入导入文件的详细目录：");
		带检测输入(位置信息.文本型, 3);
	}
	else strcpy(位置信息.文本型, "课程数据.txt");
	printf("加载课程数据・・・\n");
	课程数据 = fopen(位置信息.文本型, "r");
	if (课程数据 == NULL) {
		printf("课程数据不存在或打开失败，请联系管理员!\n");
		system("pause");//暂停界面
		system("cls");//清空界面
		return -1;
	}//正常运行返回值0
	free(课_程); 课程数量 = 0; 课_程 = NULL;//清空现有数据
	fgets(载入.文本型, 1000, 课程数据);
	while (!feof(课程数据)) {
		文件位置_当前行.整数型 = ftell(课程数据);
		fgets(载入.文本型, 1000, 课程数据);
		文件位置_下一行.整数型 = ftell(课程数据);
		fseek(课程数据, 文件位置_当前行.整数型, SEEK_SET);
		课_程 = (课程*)realloc(课_程, sizeof(课程) * ++课程数量);
		fscanf(课程数据, "%d", &课_程[课程数量 - 1].课程代码);
		if (课_程[课程数量 - 1].课程代码 == 0) {
			课程数量--;
			break;
		}
		课_程[课程数量 - 1].用户数量 = 0;
		课_程[课程数量 - 1].用户ID = NULL;
		fscanf(课程数据, "%s%d%d%d%d%d%s%d%d", 课_程[课程数量 - 1].教师代码, &课_程[课程数量 - 1].学分, &课_程[课程数量 - 1].选课性质, &课_程[课程数量 - 1].选课类型, &课_程[课程数量 - 1].学期, &课_程[课程数量 - 1].上课时间, 课_程[课程数量 - 1].课程名字, &课_程[课程数量 - 1].上课地点, &课_程[课程数量 - 1].学生上限);
		账号.整数型 = 用户_ID查询(课_程[课程数量 - 1].教师代码);
		if (账号.整数型 < 0 || 用_户[账号.整数型].权限类型 != 2) {
			printf("数据文件存在问题，请联系管理员!\n");
			system("pause");
			system("cls");
			return -1;
		}
		else {
			用_户[账号.整数型].课程代码 = (int*)realloc(用_户[账号.整数型].课程代码, sizeof(int) * ++用_户[账号.整数型].课程数量);
			用_户[账号.整数型].课程代码[用_户[账号.整数型].课程数量 - 1] = 课程数量 - 1;
		}
		if (文件位置_下一行.整数型 > ftell(用户数据))fgets(载入.文本型, 1000, 课程数据);//忽略剩余信息
	}
	fclose(课程数据);
	printf("加载课程数据√√√\n");
	return 0;
}
int 导出课程(int 操作类型) {
	临时数据 位置信息, 循环;
	if (操作类型) {
		printf("请输入导出文件的详细目录：");
		带检测输入(位置信息.文本型, 3);
	}
	else strcpy(位置信息.文本型, "课程数据.txt");
	printf("写入课程数据・・・\n");
	课程数据 = fopen(位置信息.文本型, "w");
	if (课程数据 == NULL) {
		printf("写入文件时出现错误，请联系管理员!\n");
		system("pause");
		system("cls");
		return -1;
	}
	fprintf(课程数据, "课程代码\t教师代码\t学分\t选课性质\t选课类型\t学期\t上课时间\t课程名字\t上课地点\t学生上限\n");
	for (循环.整数型 = 0; 循环.整数型 < 课程数量; 循环.整数型++)
		if (课_程[循环.整数型].课程代码 != -1)
			fprintf(课程数据, "%d\t%s\t%d\t%d\t%d\t%d\t%d\t%s\t%d\t%d\n", 课_程[循环.整数型].课程代码, 课_程[循环.整数型].教师代码, 课_程[循环.整数型].学分, 课_程[循环.整数型].选课性质, 课_程[循环.整数型].选课类型, 课_程[循环.整数型].学期, 课_程[循环.整数型].上课时间, 课_程[循环.整数型].课程名字, 课_程[循环.整数型].上课地点, 课_程[循环.整数型].学生上限);
	fprintf(课程数据, "0");
	fclose(课程数据);
	printf("写入课程数据√√√\n");
	system("pause"); system("cls");
	return 0;
}
int 导入用户(int 操作类型) {
	临时数据 位置信息, 载入, 文件位置_下一行, 文件位置_当前行, 账号;
	if (操作类型) {//定位文件位置
		printf("请输入导入文件的详细目录：");
		带检测输入(位置信息.文本型, 3);
	}
	else strcpy(位置信息.文本型, "用户数据.txt");
	printf("加载用户数据・・・\n");
	用户数据 = fopen(位置信息.文本型, "r");
	if (用户数据 == NULL) {
		printf("用户数据不存在或打开失败，请联系管理员!\n");
		system("pause");
		system("cls");
		return -1;
	}
	free(用_户); 用户数量 = 0; 用_户 = NULL;//清空现有数据
	fgets(载入.文本型, 1000, 用户数据);//跳过说明行
	while (!feof(用户数据)) {
		文件位置_当前行.整数型 = ftell(用户数据);
		fgets(载入.文本型, 1000, 用户数据);
		文件位置_下一行.整数型 = ftell(用户数据);
		fseek(用户数据, 文件位置_当前行.整数型, SEEK_SET);//复位文件指针位置
		用_户 = (用户*)realloc(用_户, sizeof(用户) * ++用户数量);//动态分配缓存用户数据
		fscanf(用户数据, "%d", &用_户[用户数量 - 1].权限类型);
		switch (用_户[用户数量 - 1].权限类型) {
		case 1:fscanf(用户数据, "%s%s", 用_户[用户数量 - 1].账号, 用_户[用户数量 - 1].密码); break;
		case 2:case 3:
			fscanf(用户数据, "%s%s%s", 用_户[用户数量 - 1].账号, 用_户[用户数量 - 1].密码, 用_户[用户数量 - 1].姓名);
			用_户[用户数量 - 1].课程数量 = 0;
			用_户[用户数量 - 1].课程代码 = NULL;
			while (文件位置_下一行.整数型 - 3 > ftell(用户数据)) {
				用_户[用户数量 - 1].课程代码 = (int*)realloc(用_户[用户数量 - 1].课程代码, sizeof(int) * ++用_户[用户数量 - 1].课程数量);//动态分配缓存课程代码和课程数量
				fscanf(用户数据, "%d", &用_户[用户数量 - 1].课程代码[用_户[用户数量 - 1].课程数量 - 1]);
			}
			break;
		}
		if (用_户[用户数量 - 1].权限类型 == 0) {
			用户数量--;
			break;
		}//判断数据末尾
		字符串加解密(用_户[用户数量 - 1].密码);
		if (文件位置_下一行.整数型 > ftell(用户数据))fgets(载入.文本型, 1000, 用户数据);//忽略剩余信息
	}
	fclose(用户数据);
	printf("加载用户数据√√√\n");
	return 0;
}
int 导出用户(int 操作类型) {
	临时数据 位置信息, 循环[2];
	if (操作类型) {
		printf("请输入导出文件的详细目录：");
		带检测输入(位置信息.文本型, 3);
	}
	else strcpy(位置信息.文本型, "用户数据.txt");
	printf("写入用户数据・・・\n");
	用户数据 = fopen(位置信息.文本型, "w");
	if (用户数据 == NULL) {
		printf("写入文件时出现错误，请联系管理员!\n");
		system("pause");
		system("cls");
		return -1;
	}
	数据校验(1);
	fprintf(用户数据, "权限类型\t账号\t密码\t姓名\t 课程代码\n");
	for (循环[0].整数型 = 0; 循环[0].整数型 < 用户数量; 循环[0].整数型++) {
		if (用_户[循环[0].整数型].权限类型 == -1) continue;
		字符串加解密(用_户[循环[0].整数型].密码);
		switch (用_户[循环[0].整数型].权限类型) {
		case 1:fprintf(用户数据, "%d\t%s\t%s\t", 用_户[循环[0].整数型].权限类型, 用_户[循环[0].整数型].账号, 用_户[循环[0].整数型].密码); break;
		case 2:fprintf(用户数据, "%d\t%s\t%s\t%s\t", 用_户[循环[0].整数型].权限类型, 用_户[循环[0].整数型].账号, 用_户[循环[0].整数型].密码, 用_户[循环[0].整数型].姓名); break;
		case 3:
			fprintf(用户数据, "%d\t%s\t%s\t%s\t ", 用_户[循环[0].整数型].权限类型, 用_户[循环[0].整数型].账号, 用_户[循环[0].整数型].密码, 用_户[循环[0].整数型].姓名);
			for (循环[1].整数型 = 0; 循环[1].整数型 < 用_户[循环[0].整数型].课程数量; 循环[1].整数型++)
				fprintf(用户数据, "%d ", 用_户[循环[0].整数型].课程代码[循环[1].整数型]);
			break;
		}
		字符串加解密(用_户[循环[0].整数型].密码);
		fprintf(用户数据, "\n");
	}
	fprintf(用户数据, "0");
	fclose(用户数据);
	printf("写入用户数据√√√\n");
	数据校验(0);
	system("pause"); system("cls");
	return 0;
}

//未完工
int 打印课表(void) {
	printf("功能开发中！");
	system("pause"); system("cls");
	return 1;
}
int 查看日志(void) {
	printf("功能开发中！");
	system("pause"); system("cls");
	return 1;
}